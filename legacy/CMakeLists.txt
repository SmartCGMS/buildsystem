CMAKE_MINIMUM_REQUIRED(VERSION 3.0)

PROJECT(gpredict3)

LIST(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/CMakeModules/")

# not specified build type => set to release build
IF (NOT CMAKE_BUILD_TYPE)
	SET(CMAKE_BUILD_TYPE Release)
ENDIF()

# the whole project (every target) needs to be build with PIC flag
# NOTE: probably broken on CMake 3.11, we will append -fPIC in a block below
#SET(CMAKE_POSITION_INDEPENDENT_CODE ON)

# find threads library (pthreads on GNU/Linux and macOS) and link it
FIND_PACKAGE(Threads REQUIRED)
SET(REQUIRED_LIBRARIES ${CMAKE_THREAD_LIBS_INIT})

# use C++20 standard
SET(CMAKE_CXX_STANDARD 20)

# default: do not link stdc++ filesystem support; several environments provide filesystem techspec implementation in a separate library (gcc, clang)
SET(LINK_STDCPPFS FALSE)

IF (${CMAKE_CXX_COMPILER_ID} STREQUAL "GNU" OR ${CMAKE_CXX_COMPILER_ID} MATCHES "Clang")

	# gcc's std::filesystem is incomplete and buggy
	IF ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
		ADD_DEFINITIONS(-DSTDCPP_FS_DISABLED)
		SET(LINK_STDCPPFS FALSE)
	# Android NDK does not support C++ std::filesystem as of version r21c
	ELSEIF (ANDROID)
		SET(LINK_STDCPPFS FALSE)
	# AppleClang includes stdc++fs as a part of standard library
	ELSEIF ("${CMAKE_CXX_COMPILER_ID}" MATCHES "Apple" AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 11.0)
		SET(LINK_STDCPPFS FALSE)
	# default: link stdc++fs
	ELSE()
		SET(LINK_STDCPPFS TRUE)
	ENDIF()

	# on GCC and Clang, we need to add libdl and and libm
	SET(REQUIRED_LIBRARIES ${REQUIRED_LIBRARIES} ${CMAKE_DL_LIBS} m)

	# append gcc+clang specific flags - report all warnings except the ones we acknowledged
	# -Wno-ignored-attributes, -Wno-unused-parameter - we decided not to follow these rules
	# -Wno-deprecated-declarations - mostly because of 3rd party libraries and their interfaces
	# -Wno-unknown-pragmas - this is due to "disable warning" pragma we use to suppress ugly warnings on MSVS
	ADD_DEFINITIONS(-Wall -Wextra -Wno-ignored-attributes -Wno-deprecated-declarations -Wno-deprecated-copy -Wno-unknown-warning-option -Wno-unknown-pragmas -Wno-unused-parameter -fPIC)

	# gcc reports a specific use case of copy semantics as deprecated, unlike Clang
	IF ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
		ADD_DEFINITIONS(-Wno-deprecated-copy -Wimplicit-fallthrough=0 -Wno-class-memaccess)
	ENDIF()

	# debug build = no optimization, add debug symbols
	SET(CMAKE_CXX_FLAGS_DEBUG "-g")

	# release build = maximum optimization, use all available mechanisms for given platform/architecture
	IF (ANDROID)
		# do not optimize with march=native when cross-compiling for Android
		SET(CMAKE_CXX_FLAGS_RELEASE "-O3")
	ELSE()
		SET(CMAKE_CXX_FLAGS_RELEASE "-O3 -march=native")
	ENDIF()
ENDIF()

IF(LINK_STDCPPFS)
	SET(REQUIRED_LIBRARIES ${REQUIRED_LIBRARIES} stdc++fs)
ENDIF()

IF("${CMAKE_SYSTEM_PROCESSOR}" MATCHES ".*armv7.*")
	MESSAGE("Warning: linking against libatomic, the host processor does not support atomic instructions")
	SET(REQUIRED_LIBRARIES ${REQUIRED_LIBRARIES} atomic)
ENDIF()

SET(DEBUG_ADDRESS_SANITIZER FALSE CACHE BOOL "Use address sanitizer")

# On Windows, use /bigobj flag to avoid linker limitation errors on common obj format
IF(WIN32)
	SET(WIN32_FLAGS /bigobj)
	
	IF(DEBUG_ADDRESS_SANITIZER)
		MESSAGE("Warning: using the address sanitizer, the resulting binaries may perform slower than usual")
		LIST(APPEND WIN32_FLAGS "/fsanitize=address")
		LIST(APPEND WIN32_FLAGS "-D_DISABLE_VECTOR_ANNOTATION")
	ENDIF()

	STRING(REPLACE ";" " " WIN32_FLAGS_STR "${WIN32_FLAGS}")
	ADD_DEFINITIONS(${WIN32_FLAGS_STR})
	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${WIN32_FLAGS_STR}")
	SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} ${WIN32_FLAGS_STR}")
	SET(CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL} ${WIN32_FLAGS_STR}")
	SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} ${WIN32_FLAGS_STR}")
	SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} ${WIN32_FLAGS_STR}")
ENDIF(WIN32)

# set output directory to 
SET(output_dir "${CMAKE_BINARY_DIR}/compiled")

# globally set output directory for single-configuration environments (GCC, ..)
SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${output_dir}")
SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${output_dir}")
SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${output_dir}")

# globally set output directory for multi-configuration environments (MSVS, ..)
FOREACH(OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES})
    SET(ORIG_OUT_CONFIG ${OUTPUTCONFIG})
    STRING(TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG)
    SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${output_dir}/${ORIG_OUT_CONFIG}")
    SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${output_dir}/${ORIG_OUT_CONFIG}")
    SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${output_dir}/${ORIG_OUT_CONFIG}")
ENDFOREACH(OUTPUTCONFIG CMAKE_CONFIGURATION_TYPES)

# component: desktop app (default: FALSE)
SET(COMPONENT_DESKTOP FALSE CACHE BOOL "Build desktop project")
# component: console app (default: TRUE)
SET(COMPONENT_CONSOLE TRUE CACHE BOOL "Build console project")
# component: insulin pump trainer (default: FALSE)
SET(COMPONENT_DOD_SIMULATOR FALSE CACHE BOOL "Build pump trainer project")
# component: network model service manager (default: FALSE)
SET(COMPONENT_NETMODEL_SERVICE FALSE CACHE BOOL "Build Network model (netmodel) service project")
# component: pathfinder solver (default: FALSE)
SET(COMPONENT_SOLVER_PATHFINDER FALSE CACHE BOOL "Build pathfinder solver")
# component: 3rd party solvers (default: FALSE); NOTE: requires additional libraries and dependencies,
#            which are not included in build by default (NLopt, pagmo, ...)
SET(COMPONENT_THIRDPARTY_SOLVERS FALSE CACHE BOOL "Build 3rd party solvers library")
# component: low-power extensions (default: FALSE)
SET(COMPONENT_LOWPOWER FALSE CACHE BOOL "Build low-power extensions")
# component: matlab connector extension (default: FALSE)
SET(COMPONENT_MATLAB_CONNECTOR FALSE CACHE BOOL "Build Matlab connector extensions")
# component: experimental (not published) modules (default: FALSE)
SET(COMPONENT_EXPERIMENTAL_MODULES FALSE CACHE BOOL "Build experimental modules")

# target platform settings
SET(PLATFORM_BUILD_AVX FALSE CACHE BOOL "Build with AVX support")
SET(PLATFORM_BUILD_AVX2 FALSE CACHE BOOL "Build with AVX2 support")
SET(PLATFORM_BUILD_AVX512 FALSE CACHE BOOL "Build with AVX512 support (F, CD)")

IF(PLATFORM_BUILD_AVX512)
	SET(AVX512_SET_ER_PF FALSE CACHE BOOL "Support AVX512 ER and PF sets")
	SET(AVX512_SET_VL_BW_DQ FALSE CACHE BOOL "Support AVX512 VL, DW and DQ sets")
	SET(AVX512_SET_IFMA_VBMI FALSE CACHE BOOL "Support AVX512 IFMA and VBMI sets")
ENDIF()

SET(Qt5_DISABLE FALSE CACHE BOOL "Disable all Qt5-related modules")

SET(COMPONENT_BLE_IMPLEMENTATION "STATIC" CACHE STRING "BLE Implementation")
SET_PROPERTY(CACHE COMPONENT_BLE_IMPLEMENTATION PROPERTY STRINGS "NONE" "QT_QBLUETOOTH")

# shared project library paths
# these are shared for all projects, and also will be included in all projects

SET(Qt5_REQUIRED FALSE)
SET(Qt5_REQUIRED_COMPONENTS )
SET(Qt5_INCLUDE_PATHS )

IF(COMPONENT_CONSOLE)
	SET(Qt5_REQUIRED TRUE)
	LIST(APPEND Qt5_REQUIRED_COMPONENTS Core Sql)
ENDIF()
IF(COMPONENT_DOD_SIMULATOR)
	SET(Qt5_REQUIRED TRUE)
	LIST(APPEND Qt5_REQUIRED_COMPONENTS Core Sql Widgets Svg Gui)
ENDIF()
IF(COMPONENT_DESKTOP)
	SET(Qt5_REQUIRED TRUE)
	LIST(APPEND Qt5_REQUIRED_COMPONENTS Core Sql Widgets Svg Gui)
ENDIF()

IF(Qt5_REQUIRED)
	FIND_PACKAGE(Qt5 COMPONENTS ${Qt5_REQUIRED_COMPONENTS})
	IF(Qt5_FOUND)
		SET(Qt5_INCLUDE_PATHS ${Qt5Core_INCLUDE_DIRS} ${Qt5Sql_INCLUDE_DIRS})
	ELSE()
		MESSAGE("No Qt5 installation found! SmartCGMS will be built without Qt-dependent components")
		SET(COMPONENT_DOD_SIMULATOR FALSE)
		SET(COMPONENT_DESKTOP FALSE)
		SET(Qt5_REQUIRED FALSE)
		SET(Qt5_REQUIRED_COMPONENTS )
		SET(Qt5_DISABLE TRUE)
		ADD_DEFINITIONS(-DDDO_NOT_USE_QT -DNOGUI)
	ENDIF()
ENDIF()

SET(EIGEN3_INCLUDE "" CACHE FILEPATH "Eigen3 header files location")
# TBB - in case TBB is required for some reason; if not, leave empty
SET(TBB_INCLUDE "" CACHE FILEPATH "Intel TBB header files location")
SET(TBB_LIBRARY "" CACHE FILEPATH "Intel TBB library files location")
# NLopt - in case 3rd party solvers are included in build
SET(NLOPT_INCLUDE "" CACHE FILEPATH "NLopt header files location")
SET(NLOPT_LIBRARY "" CACHE FILEPATH "NLopt library files location")
# Pagmo2 - in case 3rd party solvers are included in build
SET(PAGMO2_INCLUDE "" CACHE FILEPATH "pagmo2 header files location")
SET(PAGMO2_LIB_DIR "" CACHE FILEPATH "pagmo2 library directory location")
SET(PAGMO2_CONFIG_INCLUDE "" CACHE FILEPATH "pagmo2 config header file location (directory)")
# Boost - in case Pagmo2 (and 3rd party solvers) are included in build
SET(BOOST_INCLUDE "" CACHE FILEPATH "Boost header files location")
SET(BOOST_LIBRARY "" CACHE FILEPATH "Boost library files location")

# these libraries may be included in every target - include directories and library directories should be added to search paths
INCLUDE_DIRECTORIES(${Qt5_INCLUDE_PATHS} ${EIGEN3_INCLUDE} ${NLOPT_INCLUDE} ${PAGMO2_INCLUDE} ${PAGMO2_CONFIG_INCLUDE} ${BOOST_INCLUDE})
LINK_DIRECTORIES(${NLOPT_LIBRARY} ${BOOST_LIBRARY} ${TBB_LIBRARY} ${PAGMO2_LIB_DIR})

IF(APPLE)
	GET_FILENAME_COMPONENT(NLOPT_LIB_DIR "${NLOPT_LIBRARY}" DIRECTORY)
	SET(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_RPATH};${NLOPT_LIB_DIR}")
ENDIF()

# Set generic library variables, since Windows, Linux and Mac have different conventions for library naming

IF(WIN32)
	SET(LIB_PREFIX_STATIC "")
	SET(LIB_SUFFIX_STATIC ".lib")
	SET(LIB_SUFFIX_DYNAMIC ".dll")
ELSEIF(APPLE)
	SET(LIB_PREFIX_STATIC "lib")
	SET(LIB_SUFFIX_STATIC ".a")
	SET(LIB_SUFFIX_DYNAMIC ".dylib")
	SET(CMAKE_MACOSX_RPATH 1)
ELSE()
	SET(LIB_PREFIX_STATIC "lib")
	SET(LIB_SUFFIX_STATIC ".a")
	SET(LIB_SUFFIX_DYNAMIC ".so")
ENDIF()

# generic library config for imported libraries - takes library name, path and flag if the library is static or shared
FUNCTION(GEN_LIBCONF LIBNAME LIBPATH ISSTATIC)
	IF(${ISSTATIC})
		SET(INCMODE STATIC)
		SET(LIB_SUFFIX ${LIB_SUFFIX_STATIC})
	ELSE()
		SET(INCMODE SHARED)
		SET(LIB_SUFFIX ${LIB_SUFFIX_DYNAMIC})
	ENDIF()
	ADD_LIBRARY(${LIBNAME} ${INCMODE} IMPORTED GLOBAL)
	SET_TARGET_PROPERTIES(${LIBNAME} PROPERTIES IMPORTED_LOCATION "${LIBPATH}/${LIB_PREFIX_STATIC}${LIBNAME}${LIB_SUFFIX}")
	SET_TARGET_PROPERTIES(${LIBNAME} PROPERTIES IMPORTED_LOCATION_DEBUG "${LIBPATH}/${LIB_PREFIX_STATIC}${LIBNAME}${LIB_SUFFIX}")
	SET_TARGET_PROPERTIES(${LIBNAME} PROPERTIES IMPORTED_LOCATION_RELEASE "${LIBPATH}/${LIB_PREFIX_STATIC}${LIBNAME}${LIB_SUFFIX}")
	
	IF(APPLE)
		SET(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_RPATH};${LIBPATH}")
	ENDIF()
ENDFUNCTION()

# generic library config for imported libraries, for which their version (debug vs. release) is determined by attached "d"
FUNCTION(GEN_LIBCONF_D LIBNAME LIBPATH ISSTATIC)
        IF(${ISSTATIC})
                SET(INCMODE STATIC)
                SET(LIB_SUFFIX ${LIB_SUFFIX_STATIC})
        ELSE()
                SET(INCMODE SHARED)
                SET(LIB_SUFFIX ${LIB_SUFFIX_DYNAMIC})
        ENDIF()
	ADD_LIBRARY(${LIBNAME} ${INCMODE} IMPORTED GLOBAL)
	SET_TARGET_PROPERTIES(${LIBNAME} PROPERTIES IMPORTED_LOCATION "${LIBPATH}/${LIB_PREFIX_STATIC}${LIBNAME}${LIB_SUFFIX}")
	SET_TARGET_PROPERTIES(${LIBNAME} PROPERTIES IMPORTED_LOCATION_DEBUG "${LIBPATH}/${LIB_PREFIX_STATIC}${LIBNAME}d${LIB_SUFFIX}")
	SET_TARGET_PROPERTIES(${LIBNAME} PROPERTIES IMPORTED_LOCATION_RELEASE "${LIBPATH}/${LIB_PREFIX_STATIC}${LIBNAME}${LIB_SUFFIX}")
	
	IF(APPLE)
		SET(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_RPATH};${LIBPATH}")
	ENDIF()
ENDFUNCTION()

# function to configure common source subtree in all targets; called from individual CMakeLists of each and every target
FUNCTION(CONFIGURE_COMMON PROJNAME)
	# configure source groups - this is used in IDE environments, like MSVS and so
	SOURCE_GROUP("common\\desktop-console" FILES ${COMMON_DESKTOP_CONSOLE})
	SOURCE_GROUP("common\\iface" FILES ${COMMON_IFACE})
	SOURCE_GROUP("common\\lang" FILES ${COMMON_LANG})
	SOURCE_GROUP("common\\resource" FILES ${COMMON_RESOURCE})
	SOURCE_GROUP("common\\rtl" FILES ${COMMON_RTL})
	SOURCE_GROUP("common\\utils" FILES ${COMMON_UTILS})
ENDFUNCTION()

# function to configure output parameters of common target according to project settings
FUNCTION(CONFIGURE_FILTER_OUTPUT PROJNAME)
	# single-configuration environments (GCC, ..)
	SET_TARGET_PROPERTIES(${PROJNAME}
		PROPERTIES
		ARCHIVE_OUTPUT_DIRECTORY "${output_dir}/filters"
		LIBRARY_OUTPUT_DIRECTORY "${output_dir}/filters"
		RUNTIME_OUTPUT_DIRECTORY "${output_dir}/filters"
	)
	# multi-configuration environments (MSVS, ..)
	FOREACH(OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES})
		SET(ORIG_OUT_CONFIG ${OUTPUTCONFIG})
		STRING(TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG)
		SET_TARGET_PROPERTIES(${PROJNAME}
			PROPERTIES
			ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${output_dir}/${ORIG_OUT_CONFIG}/filters"
			LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${output_dir}/${ORIG_OUT_CONFIG}/filters"
			RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${output_dir}/${ORIG_OUT_CONFIG}/filters"
		)
	ENDFOREACH(OUTPUTCONFIG CMAKE_CONFIGURATION_TYPES)
	
	IF(COMPONENT_DESKTOP)
		ADD_DEPENDENCIES(gpredict3-desktop ${PROJNAME})
	ENDIF()
ENDFUNCTION()

# function to configure output parameters of common target according to project settings
FUNCTION(CONFIGURE_TARGET_OUTPUT PROJNAME OUTDIRNAME)
	# single-configuration environments (GCC, ..)
	SET_TARGET_PROPERTIES(${PROJNAME}
		PROPERTIES
		ARCHIVE_OUTPUT_DIRECTORY "${output_dir}/${OUTDIRNAME}"
		LIBRARY_OUTPUT_DIRECTORY "${output_dir}/${OUTDIRNAME}"
		RUNTIME_OUTPUT_DIRECTORY "${output_dir}/${OUTDIRNAME}"
	)
	# multi-configuration environments (MSVS, ..)
	FOREACH(OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES})
		SET(ORIG_OUT_CONFIG ${OUTPUTCONFIG})
		STRING(TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG)
		SET_TARGET_PROPERTIES(${PROJNAME}
			PROPERTIES
			ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${output_dir}/${ORIG_OUT_CONFIG}/${OUTDIRNAME}"
			LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${output_dir}/${ORIG_OUT_CONFIG}/${OUTDIRNAME}"
			RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${output_dir}/${ORIG_OUT_CONFIG}/${OUTDIRNAME}"
		)
	ENDFOREACH(OUTPUTCONFIG CMAKE_CONFIGURATION_TYPES)
ENDFUNCTION()

# macro for adding one specific RTL file to file list; this comes in handy when picking only a few files
MACRO(ADD_RTL_FILE RTLLIST RTLFILE)
	IF("${${RTLLIST}}" STREQUAL "")
		SET(${RTLLIST} "${PROJECT_SOURCE_DIR}/common/rtl/${RTLFILE}")
	ELSE()
		SET(${RTLLIST} "${${RTLLIST}};${PROJECT_SOURCE_DIR}/common/rtl/${RTLFILE}")
	ENDIF()
ENDMACRO()

# macro for adding one specific Utils file to file list; this comes in handy when picking only a few files
MACRO(ADD_UTILS_FILE UTILSLIST UTILSFILE)
	IF("${${UTILSLIST}}" STREQUAL "")
		SET(${UTILSLIST} "${PROJECT_SOURCE_DIR}/common/utils/${UTILSFILE}")
	ELSE()
		SET(${UTILSLIST} "${${UTILSLIST}};${PROJECT_SOURCE_DIR}/common/utils/${UTILSFILE}")
	ENDIF()
ENDMACRO()

# gather paths of common files
FILE(GLOB_RECURSE COMMON_IFACE "common/iface/*.cpp" "common/iface/*.h" "common/iface/*.c")
FILE(GLOB_RECURSE COMMON_LANG "common/lang/*.cpp" "common/lang/*.h" "common/lang/*.c")
FILE(GLOB_RECURSE COMMON_RESOURCE "common/resource/*.cpp" "common/resource/*.h" "common/resource/*.c")
FILE(GLOB_RECURSE COMMON_RTL "common/rtl/*.cpp" "common/rtl/*.h" "common/rtl/*.c" "common/utils/winapi_mapping.c" "common/utils/winapi_mapping.h" "common/utils/system_utils.h" "common/utils/system_utils.cpp")

LIST(FILTER COMMON_RTL EXCLUDE REGEX ".*qdb_connector.*$")

FILE(GLOB COMMON_OUT "./common/utils/ConvertUTF.cpp" "./common/utils/DebugHelper.cpp")
FILE(GLOB_RECURSE UTILS_DRAWING "./common/utils/drawing/*.cpp" "./common/utils/drawing/*.hpp" "./common/utils/drawing/*.c" "./common/utils/drawing/*.h")
IF (Qt5_DISABLED)
	FILE(GLOB QT_UTILS "./common/utils/QtUtils.cpp" "./common/utils/QtUtils.h")
ELSE()
	SET(QT_UTILS )
ENDIF()
FILE(GLOB STRING_AND_MATH_UTILS "./common/utils/string_utils.cpp" "./common/utils/string_utils.h" "./common/utils/math_utils.cpp" "./common/utils/math_utils.h")
SET(COMMON_UTILS ${COMMON_OUT} ${QT_UTILS} ${STRING_AND_MATH_UTILS} ${UTILS_DRAWING})

# set common files paths as global (each target could simply include them)
SET(COMMON_FILES "${COMMON_IFACE};${COMMON_LANG};${COMMON_RESOURCE};${COMMON_RTL};${COMMON_OUT};${STRING_AND_MATH_UTILS}" CACHE INTERNAL "")
SET(COMMON_DESKTOP_CONSOLE_FILES "${COMMON_DESKTOP_CONSOLE};${COMMON_OUT};${QT_UTILS}" CACHE INTERNAL "")
SET(COMMON_IFACE_FILES "${COMMON_IFACE}" CACHE INTERNAL "")
SET(COMMON_LANG_FILES "${COMMON_LANG}" CACHE INTERNAL "")
SET(COMMON_RESOURCE_FILES "${COMMON_RESOURCE}" CACHE INTERNAL "")
SET(COMMON_RTL_FILES "${COMMON_RTL}" CACHE INTERNAL "")

# macro for searching through directory for subdirectories
MACRO(SUBDIRLIST result curdir)
	FILE(GLOB children RELATIVE ${curdir} ${curdir}/*)
	SET(dirlist "")
	FOREACH(child ${children})
		IF(IS_DIRECTORY ${curdir}/${child})
			LIST(APPEND dirlist ${child})
		ENDIF()
	ENDFOREACH()
	SET(${result} ${dirlist})
ENDMACRO()

# link visual leak detector to Windows targets
IF(WIN32)
	SET(VLD_LIBRARY_PATH "" CACHE FILEPATH "Visual Leak Detector library location")
	IF(VLD_LIBRARY_PATH)
		GEN_LIBCONF("vld" "${VLD_LIBRARY_PATH}" TRUE)
		LINK_DIRECTORIES(${VLD_LIBRARY_PATH})
		SET(REQUIRED_LIBRARIES "${REQUIRED_LIBRARIES};vld")
	ENDIF()
ENDIF()

# link required libs to all targets
LINK_LIBRARIES(${REQUIRED_LIBRARIES})

IF(NOT COMPONENT_SOLVER_PATHFINDER)
	ADD_DEFINITIONS(-DNO_BUILD_PATHFINDER)
ENDIF()

SET(TARGETS_EXECUTABLES "" CACHE INTERNAL "" FORCE)
SET(TARGETS_LIBRARIES "" CACHE INTERNAL "" FORCE)

MACRO(SCGMS_ADD_EXECUTABLE TARGET_NAME)
	ADD_EXECUTABLE(${ARGV})
	SET(TARGETS_EXECUTABLES ${TARGETS_EXECUTABLES} ${TARGET_NAME} CACHE INTERNAL "" FORCE)
ENDMACRO()
MACRO(SCGMS_ADD_LIBRARY TARGET_NAME)
	ADD_LIBRARY(${ARGV})
	SET(TARGETS_LIBRARIES ${TARGETS_LIBRARIES} ${TARGET_NAME} CACHE INTERNAL "" FORCE)
ENDMACRO()

ADD_SUBDIRECTORY(common)

# add console repository and core repository
IF(COMPONENT_CONSOLE)
	ADD_SUBDIRECTORY(console)
ENDIF()
IF(COMPONENT_DESKTOP)
	ADD_SUBDIRECTORY(desktop)
ENDIF()

IF(COMPONENT_DOD_SIMULATOR)
	ADD_SUBDIRECTORY(dod-simulator)
ENDIF()

IF(COMPONENT_NETMODEL_SERVICE)
	ADD_SUBDIRECTORY(netmodel-service)
ENDIF()

ADD_SUBDIRECTORY(core)

IF(COMPONENT_LOWPOWER)
	ADD_SUBDIRECTORY(low-power)
ENDIF()

# implicitly MOC following libs, as we have no way to determine whether they're intended to be MOC'd or not
SET(CMAKE_AUTOMOC ON)
SET(CMAKE_INCLUDE_CURRENT_DIR ON)

# append AVX flag to target according to platform
FUNCTION(ADD_AVX_FLAG TARGETNAME)
	IF(MSVC)
		TARGET_COMPILE_OPTIONS(${TARGETNAME} INTERFACE "/arch:AVX")
	ELSE()
		TARGET_COMPILE_OPTIONS(${TARGETNAME} INTERFACE "-mavx")
	ENDIF()
ENDFUNCTION()

# append AVX2 flag to target according to platform
FUNCTION(ADD_AVX2_FLAG TARGETNAME)
	IF(MSVC)
		TARGET_COMPILE_OPTIONS(${TARGETNAME} INTERFACE "/arch:AVX2")
	ELSE()
		TARGET_COMPILE_OPTIONS(${TARGETNAME} INTERFACE "-mavx2")
	ENDIF()
ENDFUNCTION()

# duplicate library for compilation variant
FUNCTION(DUPLICATE_LIB LIB_NAME VARIANT)
    GET_TARGET_PROPERTY(LIB_SRC_FILES ${LIB_NAME} SOURCES)
    GET_TARGET_PROPERTY(LIB_LINK_LIBS ${LIB_NAME} LINK_LIBRARIES)
    GET_TARGET_PROPERTY(LIB_INCLUDE_DIRS ${LIB_NAME} INCLUDE_DIRECTORIES)
    GET_TARGET_PROPERTY(LIB_COMPILE_DEFINITIONS ${LIB_NAME} COMPILE_DEFINITIONS)
    GET_TARGET_PROPERTY(LIB_COMPILE_OPTIONS ${LIB_NAME} COMPILE_OPTIONS)
	
	SET(DUP_LIB_NAME "${LIB_NAME}_${VARIANT}")
	
    ADD_LIBRARY(${DUP_LIB_NAME} SHARED ${LIB_SRC_FILES})
	
	SET_TARGET_PROPERTIES(${DUP_LIB_NAME} PROPERTIES OUTPUT_NAME "${LIB_NAME}")

    TARGET_INCLUDE_DIRECTORIES(${DUP_LIB_NAME} PRIVATE ${LIB_INCLUDE_DIRS})

	IF(LIB_LINK_LIBS)
		LIST(FIND LIB_LINK_LIBS scgms FIND_IDX)
		IF(FIND_IDX GREATER -1)
			LIST(REMOVE_ITEM LIB_LINK_LIBS scgms)
			LIST(APPEND LIB_LINK_LIBS scgms_${VARIANT})
		ENDIF()
		TARGET_LINK_LIBRARIES(${DUP_LIB_NAME} PRIVATE ${LIB_LINK_LIBS})
	ENDIF()

    IF (LIB_COMPILE_OPTIONS)
        TARGET_COMPILE_OPTIONS(${DUP_LIB_NAME} PRIVATE ${LIB_COMPILE_OPTIONS})
    ENDIF()

    IF (LIB_COMPILE_DEFINITIONS)
        TARGET_COMPILE_DEFINITIONS(${DUP_LIB_NAME} PRIVATE ${LIB_COMPILE_DEFINITIONS})
    ENDIF()
	
	GET_TARGET_PROPERTY(LIB_ARCH_OUTPUT_DIRECTORY ${LIB_NAME} ARCHIVE_OUTPUT_DIRECTORY)
	GET_TARGET_PROPERTY(LIB_LIB_OUTPUT_DIRECTORY ${LIB_NAME} LIBRARY_OUTPUT_DIRECTORY)
	GET_TARGET_PROPERTY(LIB_RUN_OUTPUT_DIRECTORY ${LIB_NAME} RUNTIME_OUTPUT_DIRECTORY)
	STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" LIB_ARCH_OUTPUT_DIRECTORY ${LIB_ARCH_OUTPUT_DIRECTORY})
	STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" LIB_LIB_OUTPUT_DIRECTORY ${LIB_LIB_OUTPUT_DIRECTORY})
	STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" LIB_RUN_OUTPUT_DIRECTORY ${LIB_RUN_OUTPUT_DIRECTORY})
	SET_TARGET_PROPERTIES(${DUP_LIB_NAME}
		PROPERTIES
		ARCHIVE_OUTPUT_DIRECTORY "${LIB_ARCH_OUTPUT_DIRECTORY}"
		LIBRARY_OUTPUT_DIRECTORY "${LIB_LIB_OUTPUT_DIRECTORY}"
		RUNTIME_OUTPUT_DIRECTORY "${LIB_RUN_OUTPUT_DIRECTORY}"
	)
	FOREACH(OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES})
		SET(ORIG_OUT_CONFIG ${OUTPUTCONFIG})
		STRING(TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG)
		GET_TARGET_PROPERTY(LIB_ARCH_OUTPUT_DIRECTORY ${LIB_NAME} ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG})
		GET_TARGET_PROPERTY(LIB_LIB_OUTPUT_DIRECTORY ${LIB_NAME} LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG})
		GET_TARGET_PROPERTY(LIB_RUN_OUTPUT_DIRECTORY ${LIB_NAME} RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG})
		STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" LIB_ARCH_OUTPUT_DIRECTORY ${LIB_ARCH_OUTPUT_DIRECTORY})
		STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" LIB_LIB_OUTPUT_DIRECTORY ${LIB_LIB_OUTPUT_DIRECTORY})
		STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" LIB_RUN_OUTPUT_DIRECTORY ${LIB_RUN_OUTPUT_DIRECTORY})
		SET_TARGET_PROPERTIES(${DUP_LIB_NAME}
			PROPERTIES
			ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${LIB_ARCH_OUTPUT_DIRECTORY}"
			LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${LIB_LIB_OUTPUT_DIRECTORY}"
			RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${LIB_RUN_OUTPUT_DIRECTORY}"
		)
	ENDFOREACH(OUTPUTCONFIG CMAKE_CONFIGURATION_TYPES)
	
	IF(VARIANT STREQUAL "AVX")
		ADD_AVX_FLAG(${DUP_LIB_NAME})
	ENDIF()
	IF(VARIANT STREQUAL "AVX2")
		ADD_AVX2_FLAG(${DUP_LIB_NAME})
	ENDIF()
	#IF(VARIANT STREQUAL "AVX512")
	#	ADD_AVX512_FLAG_SET(${DUP_LIB_NAME})
	#ENDIF()
ENDFUNCTION()

# duplicate executable for compilation variant
FUNCTION(DUPLICATE_EXECUTABLE EXE_NAME VARIANT)
    GET_TARGET_PROPERTY(EXE_SRC_FILES ${EXE_NAME} SOURCES)
    GET_TARGET_PROPERTY(EXE_LINK_LIBS ${EXE_NAME} LINK_LIBRARIES)
    GET_TARGET_PROPERTY(EXE_INCLUDE_DIRS ${EXE_NAME} INCLUDE_DIRECTORIES)
    GET_TARGET_PROPERTY(EXE_COMPILE_DEFINITIONS ${EXE_NAME} COMPILE_DEFINITIONS)
    GET_TARGET_PROPERTY(EXE_COMPILE_OPTIONS ${EXE_NAME} COMPILE_OPTIONS)
	
	SET(DUP_EXE_NAME "${EXE_NAME}_${VARIANT}")
	
	IF (${EXE_NAME} STREQUAL "gpredict3-desktop" AND WIN32)
		ADD_EXECUTABLE(${DUP_EXE_NAME} WIN32 ${EXE_SRC_FILES})
	ELSE()
		ADD_EXECUTABLE(${DUP_EXE_NAME} ${EXE_SRC_FILES})
	ENDIF()
	
	SET_TARGET_PROPERTIES(${DUP_EXE_NAME} PROPERTIES OUTPUT_NAME "${EXE_NAME}")

    TARGET_INCLUDE_DIRECTORIES(${DUP_EXE_NAME} PRIVATE ${EXE_INCLUDE_DIRS})

	IF(EXE_LINK_LIBS)
		LIST(FIND EXE_LINK_LIBS scgms FIND_IDX)
		IF(FIND_IDX GREATER -1)
			LIST(REMOVE_ITEM EXE_LINK_LIBS scgms)
			LIST(APPEND EXE_LINK_LIBS scgms_${VARIANT})
		ENDIF()
		TARGET_LINK_LIBRARIES(${DUP_EXE_NAME} PRIVATE ${EXE_LINK_LIBS})
	ENDIF()

    IF (EXE_COMPILE_OPTIONS)
        TARGET_COMPILE_OPTIONS(${DUP_EXE_NAME} PRIVATE ${EXE_COMPILE_OPTIONS})
    ENDIF()

    IF (EXE_COMPILE_DEFINITIONS)
        TARGET_COMPILE_DEFINITIONS(${DUP_EXE_NAME} PRIVATE ${EXE_COMPILE_DEFINITIONS})
    ENDIF()
	
	GET_TARGET_PROPERTY(EXE_ARCH_OUTPUT_DIRECTORY ${EXE_NAME} ARCHIVE_OUTPUT_DIRECTORY)
	GET_TARGET_PROPERTY(EXE_LIB_OUTPUT_DIRECTORY ${EXE_NAME} LIBRARY_OUTPUT_DIRECTORY)
	GET_TARGET_PROPERTY(EXE_RUN_OUTPUT_DIRECTORY ${EXE_NAME} RUNTIME_OUTPUT_DIRECTORY)
	STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" EXE_ARCH_OUTPUT_DIRECTORY ${EXE_ARCH_OUTPUT_DIRECTORY})
	STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" EXE_LIB_OUTPUT_DIRECTORY ${EXE_LIB_OUTPUT_DIRECTORY})
	STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" EXE_RUN_OUTPUT_DIRECTORY ${EXE_RUN_OUTPUT_DIRECTORY})
	SET_TARGET_PROPERTIES(${DUP_EXE_NAME}
		PROPERTIES
		ARCHIVE_OUTPUT_DIRECTORY "${EXE_ARCH_OUTPUT_DIRECTORY}"
		LIBRARY_OUTPUT_DIRECTORY "${EXE_LIB_OUTPUT_DIRECTORY}"
		RUNTIME_OUTPUT_DIRECTORY "${EXE_RUN_OUTPUT_DIRECTORY}"
	)
	FOREACH(OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES})
		SET(ORIG_OUT_CONFIG ${OUTPUTCONFIG})
		STRING(TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG)
		GET_TARGET_PROPERTY(EXE_ARCH_OUTPUT_DIRECTORY ${EXE_NAME} ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG})
		GET_TARGET_PROPERTY(EXE_LIB_OUTPUT_DIRECTORY ${EXE_NAME} LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG})
		GET_TARGET_PROPERTY(EXE_RUN_OUTPUT_DIRECTORY ${EXE_NAME} RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG})
		STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" EXE_ARCH_OUTPUT_DIRECTORY ${EXE_ARCH_OUTPUT_DIRECTORY})
		STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" EXE_LIB_OUTPUT_DIRECTORY ${EXE_LIB_OUTPUT_DIRECTORY})
		STRING(REPLACE "${output_dir}" "${output_dir}\\${VARIANT}" EXE_RUN_OUTPUT_DIRECTORY ${EXE_RUN_OUTPUT_DIRECTORY})
		SET_TARGET_PROPERTIES(${DUP_EXE_NAME}
			PROPERTIES
			ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${EXE_ARCH_OUTPUT_DIRECTORY}"
			LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${EXE_LIB_OUTPUT_DIRECTORY}"
			RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${EXE_RUN_OUTPUT_DIRECTORY}"
		)
	ENDFOREACH(OUTPUTCONFIG CMAKE_CONFIGURATION_TYPES)
	
	IF(VARIANT STREQUAL "AVX")
		ADD_AVX_FLAG(${DUP_EXE_NAME})
	ENDIF()
	IF(VARIANT STREQUAL "AVX2")
		ADD_AVX2_FLAG(${DUP_EXE_NAME})
	ENDIF()
	#IF(VARIANT STREQUAL "AVX512")
	#	ADD_AVX512_FLAG_SET(${DUP_EXE_NAME})
	#ENDIF()
ENDFUNCTION()

# TODO: support AVX512
IF(PLATFORM_BUILD_AVX512)
	MESSAGE("AVX512 build is not supported yet")
ENDIF()

# duplicate all libraries for selected platforms
FOREACH(LIB_TARGET_NAME IN LISTS TARGETS_LIBRARIES)
	IF(PLATFORM_BUILD_AVX)
		DUPLICATE_LIB(${LIB_TARGET_NAME} "AVX")
	ENDIF()
	IF(PLATFORM_BUILD_AVX2)
		DUPLICATE_LIB(${LIB_TARGET_NAME} "AVX2")
	ENDIF()
	#IF(PLATFORM_BUILD_AVX512)
	#	DUPLICATE_LIB(${LIB_TARGET_NAME} "AVX512")
	#ENDIF()
ENDFOREACH()

# duplicate all executables for selected platforms
FOREACH(EXE_TARGET_NAME IN LISTS TARGETS_EXECUTABLES)
	IF(PLATFORM_BUILD_AVX)
		DUPLICATE_EXECUTABLE(${EXE_TARGET_NAME} "AVX")
	ENDIF()
	IF(PLATFORM_BUILD_AVX2)
		DUPLICATE_EXECUTABLE(${EXE_TARGET_NAME} "AVX2")
	ENDIF()
	#IF(PLATFORM_BUILD_AVX512)
	#	DUPLICATE_EXECUTABLE(${EXE_TARGET_NAME} "AVX512")
	#ENDIF()
ENDFOREACH()
